# Implementation Plan: Interactive RAG Chatbot, Authentication & Localization

**Branch**: `002-chatbot-auth` | **Date**: 2025-12-14 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-chatbot-auth/spec.md`

---

## Summary

Transform the Physical AI & Humanoid Robotics Docusaurus textbook into an intelligent, personalized AI learning platform. This feature implements secure user authentication (BetterAuth with GitHub/Google OAuth), a RAG chatbot powered by OpenAI Agents SDK with Qdrant vector search, real-time Urdu translation, and personalized content based on user background.

**Key Deliverables:**
1. Auth server (Node.js/Hono + BetterAuth) with email/password and OAuth
2. RAG backend (Python/FastAPI + OpenAI Agents SDK) with chat, translation, personalization
3. Document ingestion pipeline for Qdrant Cloud
4. Docusaurus frontend components (swizzled navbar, chat widget, chapter toolbar)

---

## Technical Context

**Language/Version**:
- TypeScript 5.x (auth-server, frontend)
- Python 3.10+ (RAG backend)

**Primary Dependencies**:
- Auth: Hono 4.x, BetterAuth 1.x, Drizzle ORM
- RAG: FastAPI 0.109+, OpenAI SDK, qdrant-client 1.7+
- Frontend: React 18, Docusaurus 3.x

**Storage**:
- PostgreSQL (Neon Serverless) - users, sessions, chat history, caches
- Qdrant Cloud - document embeddings

**Testing**:
- Node: Vitest
- Python: pytest
- E2E: Playwright (optional)

**Target Platform**: Web (responsive, desktop/mobile browsers)

**Project Type**: Multi-service (auth-server, backend, frontend)

**Performance Goals**:
- Chat response: <10 seconds
- Translation: <30 seconds per chapter
- Auth operations: <5 seconds

**Constraints**:
- Neon Free Tier: 0.5GB storage
- Qdrant Free Tier: 1GB vectors
- OpenAI rate limits: implement backoff

**Scale/Scope**: 50 concurrent users (SC-018)

---

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| Spec-Driven Development | ✅ PASS | Feature spec complete with acceptance criteria |
| Physical-First Design | ✅ N/A | Feature is platform tooling, not robotics content |
| Content Accuracy | ✅ PASS | RAG grounds responses in verified textbook content |
| Technology Stack | ✅ PASS | Uses Docusaurus 3, Python, aligns with constitution |

**Post-Design Re-Check:**
- All decisions documented in research.md
- No unauthorized technology additions
- Complexity justified by feature requirements

---

## Project Structure

### Documentation (this feature)

```text
specs/002-chatbot-auth/
├── plan.md              # This file
├── spec.md              # Feature specification
├── research.md          # Phase 0 research findings
├── data-model.md        # Database schema design
├── quickstart.md        # Developer quickstart guide
├── contracts/
│   ├── README.md        # API contract overview
│   ├── auth-api.yaml    # OpenAPI spec for auth server
│   └── rag-api.yaml     # OpenAPI spec for RAG backend
├── checklists/
│   └── requirements.md  # Spec quality checklist
└── tasks.md             # Implementation tasks (generated by /sp.tasks)
```

### Source Code (repository root)

```text
auth-server/                    # Node.js authentication server
├── src/
│   ├── index.ts               # Hono app entry point
│   ├── auth.ts                # BetterAuth configuration
│   ├── routes/
│   │   └── profile.ts         # User profile endpoints
│   └── db/
│       ├── client.ts          # Neon connection
│       └── schema.ts          # Drizzle schema
├── migrations/
│   ├── 001_create_core_tables.sql
│   ├── 002_create_chat_tables.sql
│   └── 003_create_cache_tables.sql
├── .env.example
├── package.json
├── tsconfig.json
└── drizzle.config.ts

backend/                        # Python RAG backend
├── main.py                    # FastAPI application
├── agent.py                   # OpenAI Agent definition
├── rag_service.py             # RAG retrieval logic
├── translation_service.py     # Urdu translation
├── personalization_service.py # Content personalization
├── memory.py                  # Conversation memory
├── db/
│   └── connection.py          # Async Postgres connection
├── models/
│   ├── chat.py                # Chat Pydantic models
│   └── user.py                # User Pydantic models
├── requirements.txt
└── .env.example

scripts/
├── ingest.py                  # Document ingestion to Qdrant
├── chunking.py                # Document chunking utilities
└── file_tracker.py            # Incremental ingestion tracking

src/                           # Docusaurus frontend (extended)
├── components/
│   ├── ChatWidget/
│   │   ├── index.tsx          # Floating chat component
│   │   ├── ChatMessage.tsx    # Message display
│   │   ├── ChatInput.tsx      # Input with context
│   │   └── styles.module.css
│   ├── ChapterToolbar/
│   │   ├── index.tsx          # Translate/Personalize buttons
│   │   └── styles.module.css
│   ├── AuthModal/
│   │   ├── index.tsx          # Login/signup modal
│   │   └── styles.module.css
│   ├── OnboardingForm/
│   │   └── index.tsx          # Background capture form
│   └── TextSelectionHandler/
│       └── index.tsx          # Selection detection
├── theme/
│   ├── Root.tsx               # Swizzled - adds providers
│   └── Navbar/
│       └── Content/
│           └── index.tsx      # Swizzled - adds auth button
├── context/
│   ├── AuthContext.tsx        # Authentication state
│   └── ChatContext.tsx        # Chat state management
├── lib/
│   ├── auth-client.ts         # BetterAuth client
│   └── api-client.ts          # RAG backend client
├── pages/
│   ├── profile.tsx            # Profile settings page
│   └── auth/
│       └── callback.tsx       # OAuth callback handler
└── css/
    └── custom.css             # Chat widget styles

docs/                          # Existing textbook content (unchanged)
```

**Structure Decision**: Multi-service architecture with separate auth (Node.js) and RAG (Python) backends, plus extended Docusaurus frontend. This separation allows:
- BetterAuth's TypeScript-native patterns
- Python's strong AI/ML ecosystem for RAG
- Independent scaling and deployment

---

## Complexity Tracking

> **No violations to justify** - design follows constitution guidelines.

---

## Implementation Phases

### Phase 1: Foundation (Auth + Basic Chat)

**Goal**: Working authentication and basic RAG chat without context features.

**Deliverables**:
- Auth server with email/password + OAuth
- User profile with background capture
- Document ingestion script
- Basic chat endpoint (no selection context)
- Chat widget in Docusaurus

**FR Coverage**: FR-001 to FR-008, FR-009 to FR-014

### Phase 2: Context & History

**Goal**: Context-aware chat with session persistence.

**Deliverables**:
- Text selection detection
- Selection-scoped chat queries
- Chat history persistence
- Session management UI

**FR Coverage**: FR-016 to FR-020, FR-031, FR-032

### Phase 3: Translation & Personalization

**Goal**: Urdu translation and personalized content.

**Deliverables**:
- Translation endpoint and caching
- Personalization endpoint and caching
- Chapter toolbar component
- Cache invalidation logic

**FR Coverage**: FR-021 to FR-030

### Phase 4: Polish & Deployment

**Goal**: Production readiness.

**Deliverables**:
- Error handling and rate limiting
- Performance optimization
- Deployment configurations
- Documentation

**FR Coverage**: All edge cases, SC-018 to SC-020

#### RAG Service - Robust Implementation Strategy

**Issue**: The `qdrant-client` library on Windows throws `AttributeError: 'QdrantClient' object has no attribute 'search'` due to corrupted/incompatible gRPC installation.

**Solution**: Implement a custom `RobustQdrantClient` class that bypasses gRPC entirely by using `httpx` for direct REST API calls to Qdrant Cloud.

**Implementation Details**:

1. **Custom Client Class** (`backend/rag_service.py`):
   ```python
   class RobustQdrantClient:
       """Custom Qdrant client using REST API via httpx (bypasses gRPC issues)."""

       def __init__(self, url: str, api_key: str):
           self.base_url = url.rstrip('/')
           self.api_key = api_key
           self.client = httpx.AsyncClient(
               headers={"api-key": api_key, "Content-Type": "application/json"},
               timeout=30.0
           )

       async def search(
           self,
           collection_name: str,
           query_vector: List[float],
           limit: int = 5,
           score_threshold: float = 0.5,
           query_filter: Optional[dict] = None
       ) -> List[dict]:
           """Search vectors via REST API."""
           endpoint = f"{self.base_url}/collections/{collection_name}/points/search"
           payload = {
               "vector": query_vector,
               "limit": limit,
               "score_threshold": score_threshold,
               "with_payload": True,
           }
           if query_filter:
               payload["filter"] = query_filter

           response = await self.client.post(endpoint, json=payload)
           response.raise_for_status()
           return response.json().get("result", [])
   ```

2. **Dependencies**: Add `httpx` to `backend/requirements.txt`

3. **Environment Configuration**:
   - `QDRANT_URL`: Qdrant Cloud REST endpoint (e.g., `https://xxx.us-east4-0.gcp.cloud.qdrant.io:6333`)
   - `QDRANT_API_KEY`: Qdrant Cloud API key
   - `OPENAI_BASE_URL`: Set to `https://generativelanguage.googleapis.com/v1beta/openai/` for Gemini compatibility
   - `OPENAI_API_KEY`: Google AI API key (for Gemini)

4. **Benefits**:
   - Bypasses local gRPC dependency issues completely
   - Works reliably on Windows without gRPC compilation
   - Direct HTTP calls are easier to debug and monitor
   - No dependency on `qdrant-client` gRPC internals

5. **Fallback Strategy**: Keep `qdrant-client` as optional dependency for environments where gRPC works correctly

---

## Risk Mitigation

| Risk | Impact | Mitigation |
|------|--------|------------|
| OpenAI rate limits | Chat unavailable | Exponential backoff, request queuing |
| Neon cold starts | Slow first auth | Pooled connections, warm-up |
| Qdrant timeout | Search fails | Graceful degradation, retry logic |
| Long translation | Poor UX | Chunked streaming, progress UI |
| OAuth misconfiguration | Auth fails | Thorough callback URL testing |
| qdrant-client gRPC issues (Windows) | Search fails | Custom REST client via httpx |

---

## Architecture Decisions

| Decision | Choice | Rationale | Alternatives Rejected |
|----------|--------|-----------|----------------------|
| Auth library | BetterAuth | TypeScript-native, Hono support, OAuth built-in | NextAuth (Next.js only), Lucia (less mature) |
| RAG framework | OpenAI Agents SDK | Direct OpenAI integration, structured tools | LangChain (heavy), custom (more work) |
| Vector DB | Qdrant Cloud | Free tier, good Python client, production-ready | Pinecone (expensive), Chroma (no cloud) |
| Database | Neon Postgres | Serverless, free tier, Drizzle support | Supabase (overkill), PlanetScale (MySQL) |
| Frontend state | React Context | Simple, no external deps, Docusaurus native | Redux (overkill), Zustand (extra dep) |
| Qdrant client | httpx REST API | Bypasses gRPC issues on Windows, more reliable | qdrant-client (gRPC broken on Windows) |

---

## Generated Artifacts

| Artifact | Path | Status |
|----------|------|--------|
| Research | `specs/002-chatbot-auth/research.md` | ✅ Complete |
| Data Model | `specs/002-chatbot-auth/data-model.md` | ✅ Complete |
| Auth API | `specs/002-chatbot-auth/contracts/auth-api.yaml` | ✅ Complete |
| RAG API | `specs/002-chatbot-auth/contracts/rag-api.yaml` | ✅ Complete |
| Quickstart | `specs/002-chatbot-auth/quickstart.md` | ✅ Complete |

---

## Next Steps

1. Run `/sp.tasks` to generate implementation tasks from this plan
2. Follow task order for phased implementation
3. Reference `quickstart.md` for local development setup
4. Use API contracts for frontend-backend integration

---

## References

- [spec.md](./spec.md) - Feature specification
- [research.md](./research.md) - Technology research and patterns
- [data-model.md](./data-model.md) - Database schema
- [quickstart.md](./quickstart.md) - Developer setup guide
- [Constitution](./.specify/memory/constitution.md) - Project principles
